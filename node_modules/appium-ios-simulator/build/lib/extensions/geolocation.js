"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("source-map-support/register");
var _lodash = _interopRequireDefault(require("lodash"));
var _support = require("@appium/support");
var _logger = _interopRequireDefault(require("../logger"));
var _teen_process = require("teen_process");
const LYFT_SET_LOCATION = 'set-simulator-location';
const DECIMAL_SEPARATOR_SCRIPT = `
use framework "Foundation"
use framework "AppKit"
use scripting additions

set theFormatter to current application's NSNumberFormatter's new()
set result to theFormatter's decimalSeparator()
log result as string
`;
async function setLocationWithLyft(udid, latitude, longitude) {
  try {
    await _support.fs.which(LYFT_SET_LOCATION);
  } catch (e) {
    throw new Error(`'${LYFT_SET_LOCATION}' binary has not been found in your PATH. ` + 'Please install it as "brew install lyft/formulae/set-simulator-location" by brew or ' + 'read https://github.com/MobileNativeFoundation/set-simulator-location to set ' + 'the binary by manual to be able to set geolocation by the library.');
  }
  try {
    await (0, _teen_process.exec)(LYFT_SET_LOCATION, ['-c', latitude, longitude, '-u', udid]);
  } catch (e) {
    throw new Error(`Failed to set geolocation with '${LYFT_SET_LOCATION}'. ` + `Original error: ${e.stderr || e.message}`);
  }
}
async function setLocationWithIdb(idb, latitude, longitude) {
  if (!idb) {
    throw new Error('Failed to set geolocation with idb because it is not installed or the "launchWithIDB" capability was not set');
  }
  try {
    await idb.setLocation(latitude, longitude);
  } catch (e) {
    throw new Error(`Failed to set geolocation with idb. Original error: ${e.stderr || e.message}`);
  }
}
async function setLocationWithAppleScript(sim, latitude, longitude, menu = 'Debug') {
  const {
    stdout,
    stderr
  } = await (0, _teen_process.exec)('osascript', ['-e', DECIMAL_SEPARATOR_SCRIPT]);
  const decimalSeparator = _lodash.default.trim(stdout || stderr);
  const [latitudeStr, longitudeStr] = [latitude, longitude].map(coord => `${coord}`.replace(/[.,]/, decimalSeparator));
  const output = await sim.executeUIClientScript(`
    tell application "System Events"
      tell process "Simulator"
        set featureName to "Custom Location"
        set dstMenuItem to menu item (featureName & "â€¦") of menu 1 of menu item "Location" of menu 1 of menu bar item "${menu}" of menu bar 1
        click dstMenuItem
        delay 1
        set value of text field 1 of window featureName to "${latitudeStr}"
        delay 0.5
        set value of text field 2 of window featureName to "${longitudeStr}"
        delay 0.5
        click button "OK" of window featureName
        delay 0.5
        set isInvisible to (not (exists (window featureName)))
      end tell
    end tell
  `);
  _logger.default.debug(`Geolocation parameters dialog accepted: ${output}`);
  if (_lodash.default.trim(output) !== 'true') {
    throw new Error(`Failed to set geolocation with AppleScript. Original error: ${output}`);
  }
}
const extensions = {};
extensions.setGeolocation = async function setGeolocation(latitude, longitude) {
  const locationSetters = [async () => await setLocationWithLyft(this.udid, latitude, longitude), async () => await setLocationWithIdb(this.idb, latitude, longitude), async () => await setLocationWithAppleScript(this, latitude, longitude, this._locationMenu)];
  let lastError;
  for (const setter of locationSetters) {
    try {
      await setter();
      return true;
    } catch (e) {
      _logger.default.info(e.message);
      lastError = e;
    }
  }
  throw lastError;
};
var _default = extensions;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbG9kYXNoIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfc3VwcG9ydCIsIl9sb2dnZXIiLCJfdGVlbl9wcm9jZXNzIiwiTFlGVF9TRVRfTE9DQVRJT04iLCJERUNJTUFMX1NFUEFSQVRPUl9TQ1JJUFQiLCJzZXRMb2NhdGlvbldpdGhMeWZ0IiwidWRpZCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiZnMiLCJ3aGljaCIsImUiLCJFcnJvciIsImV4ZWMiLCJzdGRlcnIiLCJtZXNzYWdlIiwic2V0TG9jYXRpb25XaXRoSWRiIiwiaWRiIiwic2V0TG9jYXRpb24iLCJzZXRMb2NhdGlvbldpdGhBcHBsZVNjcmlwdCIsInNpbSIsIm1lbnUiLCJzdGRvdXQiLCJkZWNpbWFsU2VwYXJhdG9yIiwiXyIsInRyaW0iLCJsYXRpdHVkZVN0ciIsImxvbmdpdHVkZVN0ciIsIm1hcCIsImNvb3JkIiwicmVwbGFjZSIsIm91dHB1dCIsImV4ZWN1dGVVSUNsaWVudFNjcmlwdCIsImxvZyIsImRlYnVnIiwiZXh0ZW5zaW9ucyIsInNldEdlb2xvY2F0aW9uIiwibG9jYXRpb25TZXR0ZXJzIiwiX2xvY2F0aW9uTWVudSIsImxhc3RFcnJvciIsInNldHRlciIsImluZm8iLCJfZGVmYXVsdCIsImV4cG9ydHMiLCJkZWZhdWx0Il0sInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2V4dGVuc2lvbnMvZ2VvbG9jYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZzfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5cbmNvbnN0IExZRlRfU0VUX0xPQ0FUSU9OID0gJ3NldC1zaW11bGF0b3ItbG9jYXRpb24nO1xuY29uc3QgREVDSU1BTF9TRVBBUkFUT1JfU0NSSVBUID0gYFxudXNlIGZyYW1ld29yayBcIkZvdW5kYXRpb25cIlxudXNlIGZyYW1ld29yayBcIkFwcEtpdFwiXG51c2Ugc2NyaXB0aW5nIGFkZGl0aW9uc1xuXG5zZXQgdGhlRm9ybWF0dGVyIHRvIGN1cnJlbnQgYXBwbGljYXRpb24ncyBOU051bWJlckZvcm1hdHRlcidzIG5ldygpXG5zZXQgcmVzdWx0IHRvIHRoZUZvcm1hdHRlcidzIGRlY2ltYWxTZXBhcmF0b3IoKVxubG9nIHJlc3VsdCBhcyBzdHJpbmdcbmA7XG5cbi8qKlxuICogU2V0IGN1c3RvbSBnZW9sb2NhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGUgZ2l2ZW4gU2ltdWxhdG9yIHVzaW5nIExZRlRfU0VUX0xPQ0FUSU9OLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIHVkaWQgdG8gc2V0IHRoZSBnaXZlbiBnZW9sb2NhdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsYXRpdHVkZSAtIFRoZSBsYXRpdHVkZSB2YWx1ZSwgd2hpY2ggaXMgZ29pbmcgdG8gYmUgZW50ZXJlZFxuICogICBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGVkaXQgZmllbGQsIGZvciBleGFtcGxlICczOSwwMDA2Jy5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbG9uZ2l0dWRlIC0gVGhlIGxvbmdpdHVkZSB2YWx1ZSwgd2hpY2ggaXMgZ29pbmcgdG8gYmUgZW50ZXJlZFxuICogICBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGVkaXQgZmllbGQsIGZvciBleGFtcGxlICcxOSwwMDY4Jy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCBmYWlsZWQgdG8gc2V0IHRoZSBsb2NhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRMb2NhdGlvbldpdGhMeWZ0ICh1ZGlkLCBsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud2hpY2goTFlGVF9TRVRfTE9DQVRJT04pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtMWUZUX1NFVF9MT0NBVElPTn0nIGJpbmFyeSBoYXMgbm90IGJlZW4gZm91bmQgaW4geW91ciBQQVRILiBgICtcbiAgICAgICdQbGVhc2UgaW5zdGFsbCBpdCBhcyBcImJyZXcgaW5zdGFsbCBseWZ0L2Zvcm11bGFlL3NldC1zaW11bGF0b3ItbG9jYXRpb25cIiBieSBicmV3IG9yICcgK1xuICAgICAgJ3JlYWQgaHR0cHM6Ly9naXRodWIuY29tL01vYmlsZU5hdGl2ZUZvdW5kYXRpb24vc2V0LXNpbXVsYXRvci1sb2NhdGlvbiB0byBzZXQgJyArXG4gICAgICAndGhlIGJpbmFyeSBieSBtYW51YWwgdG8gYmUgYWJsZSB0byBzZXQgZ2VvbG9jYXRpb24gYnkgdGhlIGxpYnJhcnkuJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IGV4ZWMoTFlGVF9TRVRfTE9DQVRJT04sIFtcbiAgICAgICctYycsIGxhdGl0dWRlLCBsb25naXR1ZGUsXG4gICAgICAnLXUnLCB1ZGlkXG4gICAgXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXQgZ2VvbG9jYXRpb24gd2l0aCAnJHtMWUZUX1NFVF9MT0NBVElPTn0nLiBgICtcbiAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLnN0ZGVyciB8fCBlLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgY3VzdG9tIGdlb2xvY2F0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBnaXZlbiBTaW11bGF0b3IgdXNpbmcgaWRiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpZGIgLSBUaGUgSURCIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gKiAgIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgZWRpdCBmaWVsZCwgZm9yIGV4YW1wbGUgJzM5LDAwMDYnLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsb25naXR1ZGUgLSBUaGUgbG9uZ2l0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gKiAgIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgZWRpdCBmaWVsZCwgZm9yIGV4YW1wbGUgJzE5LDAwNjgnLlxuICogQHRocm93cyB7RXJyb3J9IElmIGl0IGZhaWxlZCB0byBzZXQgdGhlIGxvY2F0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldExvY2F0aW9uV2l0aElkYiAoaWRiLCBsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG4gIGlmICghaWRiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2V0IGdlb2xvY2F0aW9uIHdpdGggaWRiIGJlY2F1c2UgaXQgaXMgbm90IGluc3RhbGxlZCBvciB0aGUgXCJsYXVuY2hXaXRoSURCXCIgY2FwYWJpbGl0eSB3YXMgbm90IHNldCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBpZGIuc2V0TG9jYXRpb24obGF0aXR1ZGUsIGxvbmdpdHVkZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXQgZ2VvbG9jYXRpb24gd2l0aCBpZGIuIE9yaWdpbmFsIGVycm9yOiAke2Uuc3RkZXJyIHx8IGUubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBjdXN0b20gZ2VvbG9jYXRpb24gcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIFNpbXVsYXRvciB1c2luZyBBcHBsZVNjcmlwdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaW0gLSBUaGUgU2ltdWxhdG9yWGNvZGUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gKiAgIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgZWRpdCBmaWVsZCwgZm9yIGV4YW1wbGUgJzM5LDAwMDYnLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsb25naXR1ZGUgLSBUaGUgbG9uZ2l0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gKiAgIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgZWRpdCBmaWVsZCwgZm9yIGV4YW1wbGUgJzE5LDAwNjgnLlxuICogQHBhcmFtIHtzdHJpbmd9IFttZW51PURlYnVnXSAtIFRoZSBtZW51IGZpZWxkIGluIHdoaWNoIHRoZSAnTG9jYXRpb24nIGZlYXR1cmUgaXMgZm91bmRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCBmYWlsZWQgdG8gc2V0IHRoZSBsb2NhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRMb2NhdGlvbldpdGhBcHBsZVNjcmlwdCAoc2ltLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBtZW51ID0gJ0RlYnVnJykge1xuICAvLyBNYWtlIHN1cmUgc3lzdGVtLXdpZGUgZGVjaW1hbCBzZXBhcmF0b3IgaXMgdXNlZFxuICBjb25zdCB7c3Rkb3V0LCBzdGRlcnJ9ID0gYXdhaXQgZXhlYygnb3Nhc2NyaXB0JywgWyctZScsIERFQ0lNQUxfU0VQQVJBVE9SX1NDUklQVF0pO1xuICBjb25zdCBkZWNpbWFsU2VwYXJhdG9yID0gXy50cmltKHN0ZG91dCB8fCBzdGRlcnIpO1xuICBjb25zdCBbbGF0aXR1ZGVTdHIsIGxvbmdpdHVkZVN0cl0gPSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV1cbiAgICAubWFwKChjb29yZCkgPT4gYCR7Y29vcmR9YC5yZXBsYWNlKC9bLixdLywgZGVjaW1hbFNlcGFyYXRvcikpO1xuXG4gIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNpbS5leGVjdXRlVUlDbGllbnRTY3JpcHQoYFxuICAgIHRlbGwgYXBwbGljYXRpb24gXCJTeXN0ZW0gRXZlbnRzXCJcbiAgICAgIHRlbGwgcHJvY2VzcyBcIlNpbXVsYXRvclwiXG4gICAgICAgIHNldCBmZWF0dXJlTmFtZSB0byBcIkN1c3RvbSBMb2NhdGlvblwiXG4gICAgICAgIHNldCBkc3RNZW51SXRlbSB0byBtZW51IGl0ZW0gKGZlYXR1cmVOYW1lICYgXCLigKZcIikgb2YgbWVudSAxIG9mIG1lbnUgaXRlbSBcIkxvY2F0aW9uXCIgb2YgbWVudSAxIG9mIG1lbnUgYmFyIGl0ZW0gXCIke21lbnV9XCIgb2YgbWVudSBiYXIgMVxuICAgICAgICBjbGljayBkc3RNZW51SXRlbVxuICAgICAgICBkZWxheSAxXG4gICAgICAgIHNldCB2YWx1ZSBvZiB0ZXh0IGZpZWxkIDEgb2Ygd2luZG93IGZlYXR1cmVOYW1lIHRvIFwiJHtsYXRpdHVkZVN0cn1cIlxuICAgICAgICBkZWxheSAwLjVcbiAgICAgICAgc2V0IHZhbHVlIG9mIHRleHQgZmllbGQgMiBvZiB3aW5kb3cgZmVhdHVyZU5hbWUgdG8gXCIke2xvbmdpdHVkZVN0cn1cIlxuICAgICAgICBkZWxheSAwLjVcbiAgICAgICAgY2xpY2sgYnV0dG9uIFwiT0tcIiBvZiB3aW5kb3cgZmVhdHVyZU5hbWVcbiAgICAgICAgZGVsYXkgMC41XG4gICAgICAgIHNldCBpc0ludmlzaWJsZSB0byAobm90IChleGlzdHMgKHdpbmRvdyBmZWF0dXJlTmFtZSkpKVxuICAgICAgZW5kIHRlbGxcbiAgICBlbmQgdGVsbFxuICBgKTtcbiAgbG9nLmRlYnVnKGBHZW9sb2NhdGlvbiBwYXJhbWV0ZXJzIGRpYWxvZyBhY2NlcHRlZDogJHtvdXRwdXR9YCk7XG4gIGlmIChfLnRyaW0ob3V0cHV0KSAhPT0gJ3RydWUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2V0IGdlb2xvY2F0aW9uIHdpdGggQXBwbGVTY3JpcHQuIE9yaWdpbmFsIGVycm9yOiAke291dHB1dH1gKTtcbiAgfVxufVxuXG5jb25zdCBleHRlbnNpb25zID0ge307XG5cbi8qKlxuICogU2V0IGN1c3RvbSBnZW9sb2NhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGUgZ2l2ZW4gU2ltdWxhdG9yIHVzaW5nIEFwcGxlU2NyaXB0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbGF0aXR1ZGUgLSBUaGUgbGF0aXR1ZGUgdmFsdWUsIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGVudGVyZWRcbiAqICAgaW50byB0aGUgY29ycmVzcG9uZGluZyBlZGl0IGZpZWxkLCBmb3IgZXhhbXBsZSAnMzksMDAwNicuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUgdmFsdWUsIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGVudGVyZWRcbiAqICAgaW50byB0aGUgY29ycmVzcG9uZGluZyBlZGl0IGZpZWxkLCBmb3IgZXhhbXBsZSAnMTksMDA2OCcuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVycyBoYXZlIGNvcnJlY3QgZm9ybWF0IGFuZCB3ZXJlIHN1Y2Nlc3NmdWxseSBhY2NlcHRlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgc2V0dGluZyB0aGUgbG9jYXRpb25cbiAqL1xuZXh0ZW5zaW9ucy5zZXRHZW9sb2NhdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIHNldEdlb2xvY2F0aW9uIChsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG4gIGNvbnN0IGxvY2F0aW9uU2V0dGVycyA9IFtcbiAgICBhc3luYyAoKSA9PiBhd2FpdCBzZXRMb2NhdGlvbldpdGhMeWZ0KHRoaXMudWRpZCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSksXG4gICAgYXN5bmMgKCkgPT4gYXdhaXQgc2V0TG9jYXRpb25XaXRoSWRiKHRoaXMuaWRiLCBsYXRpdHVkZSwgbG9uZ2l0dWRlKSxcbiAgICBhc3luYyAoKSA9PiBhd2FpdCBzZXRMb2NhdGlvbldpdGhBcHBsZVNjcmlwdCh0aGlzLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB0aGlzLl9sb2NhdGlvbk1lbnUpLFxuICBdO1xuXG4gIGxldCBsYXN0RXJyb3I7XG4gIGZvciAoY29uc3Qgc2V0dGVyIG9mIGxvY2F0aW9uU2V0dGVycykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZXR0ZXIoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5pbmZvKGUubWVzc2FnZSk7XG4gICAgICBsYXN0RXJyb3IgPSBlO1xuICAgIH1cbiAgfVxuICB0aHJvdyBsYXN0RXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbnNpb25zO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLElBQUFBLE9BQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFDLFFBQUEsR0FBQUQsT0FBQTtBQUNBLElBQUFFLE9BQUEsR0FBQUgsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFHLGFBQUEsR0FBQUgsT0FBQTtBQUVBLE1BQU1JLGlCQUFpQixHQUFHLHdCQUF3QjtBQUNsRCxNQUFNQyx3QkFBd0IsR0FBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFZRCxlQUFlQyxtQkFBbUJBLENBQUVDLElBQUksRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUU7RUFDN0QsSUFBSTtJQUNGLE1BQU1DLFdBQUUsQ0FBQ0MsS0FBSyxDQUFDUCxpQkFBaUIsQ0FBQztFQUNuQyxDQUFDLENBQUMsT0FBT1EsQ0FBQyxFQUFFO0lBQ1YsTUFBTSxJQUFJQyxLQUFLLENBQUUsSUFBR1QsaUJBQWtCLDRDQUEyQyxHQUMvRSxzRkFBc0YsR0FDdEYsK0VBQStFLEdBQy9FLG9FQUFvRSxDQUFDO0VBQ3pFO0VBRUEsSUFBSTtJQUNGLE1BQU0sSUFBQVUsa0JBQUksRUFBQ1YsaUJBQWlCLEVBQUUsQ0FDNUIsSUFBSSxFQUFFSSxRQUFRLEVBQUVDLFNBQVMsRUFDekIsSUFBSSxFQUFFRixJQUFJLENBQ1gsQ0FBQztFQUNKLENBQUMsQ0FBQyxPQUFPSyxDQUFDLEVBQUU7SUFDVixNQUFNLElBQUlDLEtBQUssQ0FBRSxtQ0FBa0NULGlCQUFrQixLQUFJLEdBQ3RFLG1CQUFrQlEsQ0FBQyxDQUFDRyxNQUFNLElBQUlILENBQUMs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